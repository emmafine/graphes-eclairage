# -*- coding: utf-8 -*-
"""
@author: thebe
"""

import random
import numpy as np


'''
Creates an reference solution population 
'''
def create_reference_solution(chromosome_length):
    number_of_ones = int(chromosome_length / 2)
    
    # Build an array with an equal mix of zero and ones
    reference = np.zeros(chromosome_length)
    reference[0: number_of_ones] = 1

    # Shuffle the array to mix the zeros and ones
    np.random.shuffle(reference)
    
    print(reference)
    return reference 


'''
In our model, chromosone_length refers to the number of total paths.
Each starting population is a possible map solution.
'''
def create_starting_population(individuals, chromosome_length):
    # Set up an initial array of all zeros
    population = np.zeros((individuals, chromosome_length))
    # Loop through each row (individual)
    for i in range(individuals):
        # Choose a random number of ones to create
        ones = random.randint(0, chromosome_length)
        # Change the required number of zeros to ones
        population[i, 0:ones] = 1
        # Shuffle row
        np.random.shuffle(population[i])
    #print(population)
    return population


'''
Compares the starting population to the reference solution and give a fitness score
'''
def calculate_fitness(reference, population):
    # Create an array of True/False compared to solution
    identical_to_reference = population == reference
    # Sum number of genes that are identical to the solution
    fitness_scores = identical_to_reference.sum(axis=1)
    #print(fitness_scores)
    return fitness_scores


'''
Selects best individuals
'''
def select_best_individuals(population, scores):
    # Get population size
    population_size = len(scores)
    
    # Pick individuals
    ind_1 = random.randint(0, population_size-1)
    ind_2 = random.randint(0, population_size-1)
    
    # Get fitness score for each
    ind_1_fitness = scores[ind_1]
    ind_2_fitness = scores[ind_2]
    
    # Identify individual with highest fitness
    if ind_1_fitness >= ind_2_fitness:
        winner = ind_1
    else:
        winner = ind_2
    
    # Return the chromsome of the winner
    return population[winner, :]

'''
Crossing over
'''
def breed_by_crossover(parent_1, parent_2):
    # Get length of chromosome
    chromosome_length = len(parent_1)
    
    # Pick crossover point, avoding ends of chromsome
    crossover_point = random.randint(1,chromosome_length-1)
    
    # Create children. np.hstack joins two arrays
    child_1 = np.hstack((parent_1[0:crossover_point],
                        parent_2[crossover_point:]))
    
    child_2 = np.hstack((parent_2[0:crossover_point],
                        parent_1[crossover_point:]))
    
    # Return children
    return child_1, child_2
    
'''
Random mutation
'''
def randomly_mutate_population(population, mutation_probability):
    
    # Apply random mutation
        random_mutation_array = np.random.random(
            size=(population.shape))
        
        random_mutation_boolean = \
            random_mutation_array <= mutation_probability

        population[random_mutation_boolean] = \
        np.logical_not(population[random_mutation_boolean])
        
        # Return mutation population
        return population
    
    
    
'''
 *************************************
 ******** MAIN ALGORITHM CODE ********
 *************************************
'''

# Set general parameters
chromosome_length = 10
population_size = 100
maximum_generation = 50
best_score_progress = [] # Tracks progress

# Create reference solution 
# (this is used just to illustrate GAs)
reference = create_reference_solution(chromosome_length)

# Create starting population
population = create_starting_population(population_size, chromosome_length)

# Display best score in starting population
scores = calculate_fitness(reference, population)
best_score = np.max(scores)/chromosome_length * 100
print ('Starting best score, % target: ',best_score)

# Add starting best score to progress tracker
best_score_progress.append(best_score)

# Now we'll go through the generations of genetic algorithm
for generation in range(maximum_generation):
    # Create an empty list for new population
    new_population = [] 
    
    # Create new popualtion generating two children at a time
    for i in range(int(population_size/2)):
        parent_1 = select_best_individuals(population, scores)
        parent_2 = select_best_individuals(population, scores)
        child_1, child_2 = breed_by_crossover(parent_1, parent_2)
        new_population.append(child_1)
        new_population.append(child_2)
    
    # Replace the old population with the new one
    population = np.array(new_population)

    # Apply mutation
    mutation_rate = 0.002
    population = randomly_mutate_population(population, mutation_rate)
    
    # Score best solution, and add to tracker
    scores = calculate_fitness(reference, population)
    best_score = np.max(scores)/chromosome_length * 100
    best_score_progress.append(best_score)

# GA has completed required generation
print ('End best score, % target: ', best_score)

# Plot progress
import matplotlib.pyplot as plt
plt.plot(best_score_progress)
plt.xlabel('Generation')
plt.ylabel('Best score (% target)')
plt.show()
